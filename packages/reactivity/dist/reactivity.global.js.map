{"version":3,"file":"reactivity.global.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/proxyHandlers/mutableHandlers.ts","../src/proxyHandlers/shallowReactiveHandlers.ts","../src/proxyHandlers/readonlyHandlers.ts","../src/proxyHandlers/shallowReadonlyHandlers.ts","../src/reactive.ts"],"sourcesContent":["/**\n *  判断是否是对象类型（数组，普通对象等）\n */\nexport const isObject = function (value: any) {\n  return typeof value === 'object' && value !== null\n}\n\n/**\n * 判断是不是数组\n */\nexport const isArray = Array.isArray\n\n/**\n * 判断是不是函数\n */\nexport const isFunction = function (value: any) {\n  return typeof value === 'function'\n}\n\n/**\n * 判断是不是整型\n */\nexport const isNumber = function (value: any) {\n  return typeof value === 'number'\n}\n\n/**\n * 判断是不是字符串\n */\nexport const isString = function (value: any) {\n  return typeof value === 'string'\n}\n\n/**\n * 判断是不是数字类型字符串\n */\nexport const isIntegerKey = function (value: any) {\n  return parseInt(value) + '' === value\n}\n\n/**\n * 判断是不是实例属性\n */\nexport const hasOwnProperty = function (target: Record<string, any>, key: string) {\n  return target.hasOwnProperty(key)\n}\n\n/**\n * 判断数组或者对象的对应key是新增还是修改\n * 思考：对象和数组分别如何知道是新增还是修改\n * 对象：找对应key是否有值，有就是修改，没就是新增\n * 数组：找对应索引是否比数组长度小，如果小说明这个位置是有元素的，那就是修改，否则就是新增\n */\nexport const isKeyExist = function (target: Record<string, any>, key: string) {\n  return isArray(target) && isIntegerKey(key)\n    ? Number(key) < target.length\n    : hasOwnProperty(target, key as string)\n}\n\n/**\n * 判断值是否修改了\n */\nexport const hasChanged = function (oldValue: any, newValue: any) {\n  return oldValue !== newValue\n}\n","import { isArray, isIntegerKey } from '@vue/shared'\nimport { EmitEvent } from './types'\n\ntype IReactEffect = (...args: any[]) => any\nlet uid = 0\nlet activeEffect: (...args: any[]) => any // 当前正在运行的reactiveEffect\nconst reactiveEffectStack: Array<IReactEffect> = []\nexport const targetMap = new WeakMap<\n  Record<string, any>,\n  Map<string, Set<IReactEffect>>\n>()\n\n/** 触发更新，重新执行reactiveEffect */\nexport function emit(\n  eventType: EmitEvent,\n  target: Record<string, any>,\n  key?: string,\n  newValue?: any,\n  oldValue?: any\n) {\n  /**\n   * 如果属性没有收集过依赖，那么直接返回\n   */\n  let dependenciesMap = targetMap.get(target)\n  if (!dependenciesMap) return\n\n  const reactiveEffectsCollectSet = new Set<IReactEffect>() // 待会将所有要执行的reactiveEffect集中到这里头，然后一起执行\n  const add = function (reactiveEffectsSet: Set<IReactEffect>) {\n    if (reactiveEffectsSet) {\n      // ⚠️：这个是一个Set做循环\n      reactiveEffectsSet.forEach((reactiveEffect) => {\n        reactiveEffectsCollectSet.add(reactiveEffect)\n      })\n    }\n  }\n  // 1. 看看修改的是不是数组的长度，因为改数组的长度影响是比较大的\n  if (isArray(target) && key === 'length') {\n    // 如果对应的长度有依赖收集就需要更新\n    // ⚠️：这是一个map循环，第一个是value，第二个就是key\n    dependenciesMap.forEach((reactiveEffectsSet, key) => {\n      // 如果更改的长度小于收集的索引，那么索引也需要触发effect重新执行\n      if (key === 'length' || key > newValue) {\n        add(reactiveEffectsSet)\n      }\n    })\n  } else {\n    // 可能是对象\n    if (key !== undefined) {\n      // 在这个地方肯定是修改，因为key存在\n      add(dependenciesMap.get(key) as Set<IReactEffect>)\n    }\n    // 如果修改了数组当中的某一个索引，怎么办？\n    switch (eventType) {\n      case EmitEvent.ADD: // 如果添加了一个索引，那就触发长度的更新\n        if (isArray(target) && isIntegerKey(key)) {\n          add(dependenciesMap.get('length') as Set<IReactEffect>)\n        }\n    }\n  }\n  reactiveEffectsCollectSet.forEach((reactiveEffect) => reactiveEffect())\n}\n/**\n * createReactiveEffect就做了一件事：创建一个reactiveEffect，并返回这个reactiveEffect\n */\nfunction createReactiveEffect(\n  fn: (...args: any[]) => any,\n  options: Record<string, any> = {}\n): (...args: any[]) => any {\n  /**\n   * 直接activeEffect= reactiveEffect的弊端\n   * 万一用户，按如下这么写\n   * effect(() => {\n   *   console.log(state.name) -> 此时activeEffect是reactiveEffect.uid 是0\n   *   effect(() => {\n   *     console.log(state.age) -> 此时activeEffect是reactiveEffect.uid 是1\n   *   })\n   *   console.log(state.school) -> 此时activeEffect是reactiveEffect.uid 是1\n   * })\n   * 我们发现在同一个外层作用域activeEffect变了。从uid0变成uid1的reactiveEffect\n   * 那么一个作用域两个不同的reactiveEffect，最终函数执行逻辑就不同了。\n   * 而我们想要的是跑到外层的时候，activeEffect回到uid0的reactiveEffect\n   * 因此我们需要使用一个栈结构去解决这个问题\n   */\n  const reactiveEffect = function () {\n    if (!reactiveEffectStack.includes(reactiveEffect)) {\n      // 保证reactiveEffect没有加入reactiveEffectStack\n      // 因为用户可能使用effect(() => { state.index ++ })\n      // 用户用了++,就不断触发这个函数了，为了防止这一点，需要先判断一下\n      let result\n      try {\n        reactiveEffectStack.push(reactiveEffect)\n        activeEffect = reactiveEffectStack[reactiveEffectStack.length - 1]\n        result = fn() // 这传入effect的函数里头大部分时候都是会取值，一旦取值了，就会触发proxy handler的get方法\n      } finally {\n        reactiveEffectStack.pop()\n        activeEffect = reactiveEffectStack[reactiveEffectStack.length - 1]\n      }\n      return result\n    }\n  }\n  reactiveEffect.uid = uid++ // 给本次创建的reactiveEffect函数一个唯一序号，用于区分不同的reactiveEffect函数\n  reactiveEffect._isEffect = true // 同时需要给创建reactiveEffect一个标志，知道这就是一个reactiveEffect函数\n  reactiveEffect.raw = fn // 同时还要知道一个reactiveEffect对应的原始响应函数是谁，是fn\n  reactiveEffect.options = options // 同时再接着把传入effect中的用户对effect配置保存，便于之后使用\n  return reactiveEffect\n}\n\n/**\n * 收集依赖的问题：如何知道现在准备建立联系的key对应的reactiveEffect是哪一个？并且获取到它来建立联系\n * 解决的方式：设置一个activeEffect，在createReactiveEffect创建一个新的reactiveEffect时，给activeEffect赋值这个ractiveEffect\n * 然后再收集依赖collectDependency的时候将activeEffect取出来用（可以理解成两者在进行通信）\n * collectDependency的实现目标：让对象中的某个属性，收集它对应的reactiveEffect函数，这个值放在了activeEffect\n * 依赖收集其实就干了一件事：让key跟它的reactiveEffect建立联系（本质就是key跟放进effect中的那个函数fn建立联系）\n * 因为reactiveEffect执行了，必定fn也执行。reactiveEffect其实就是在fn基础上，再包装了一些东西，做了额外操作（AOP思想）\n * */\nexport function collectDependency(target: Record<string, any>, key: string) {\n  if (!activeEffect) {\n    /**\n     * 要知道如果effect(() => { state.name })只要这么用，一定会产生一个reactiveEffect\n     * 这个activeEffect也是肯定有值的，如果没有说明肯定没在effect用\n     */\n    return\n  }\n\n  /** WeakMap {\n   *    key: { name: jaylen }\n   *    value: Map { // dependenciesMap\n   *      key : name\n   *      value:\n   *     }\n   * }\n   */\n  let dependenciesMap = targetMap.get(target)\n  if (!dependenciesMap) {\n    dependenciesMap = new Map<string, Set<IReactEffect>>()\n    targetMap.set(target, dependenciesMap)\n  }\n  /**\n   * Set [reactiveEffect, reactiveEffect]\n   */\n  let reactiveEffectsSet = dependenciesMap.get(key)\n  if (!reactiveEffectsSet) {\n    reactiveEffectsSet = new Set<IReactEffect>()\n    dependenciesMap.set(key, reactiveEffectsSet)\n  }\n\n  if (!reactiveEffectsSet.has(activeEffect)) {\n    reactiveEffectsSet.add(activeEffect)\n  }\n\n  console.log('TargetMap', targetMap)\n}\n\n/**\n * effect的实现目标：做到能够让函数fn里头的数据变化了，这整个函数就能够重新执行\n * 要实现这个效果，必须想办法保存fn，将fn跟fn函数体里头使用的数据对应起来。\n * 方法： 函数fn在执行的时候是会取值的，取值就会走proxy的handler中的get handler。\n * 只需要在get当中让获取值的key属性，和使用的effect产生关联就可以解决对应的关系。其实术语叫做依赖收集\n * 每次调用一次effect，都会重新创建createReactiveEffect一个新的reactiveEffect\n */\nexport function effect(fn: (...args: any[]) => any, options: Record<string, any> = {}) {\n  const reactiveEffect = createReactiveEffect(fn, options)\n\n  if (!options.lazy) {\n    // 如果说，配置当中用户对lazy属性的值传入false或者压根没传这个lazy的话，也就是没有告诉Vue需要懒执行的话\n    reactiveEffect() // 那么，响应式的effect，默认地，是会先执行一次的。其实就是立即执行一次fn\n  }\n\n  return reactiveEffect\n}\n","import { hasChanged, isKeyExist, isObject } from '@vue/shared'\nimport { collectDependency, emit } from '../effect'\nimport { reactive } from '../reactive'\nimport { EmitEvent } from '../types'\n\nconst mutableHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    let value = Reflect.get(target, key, receiver)\n    // ⚠️：如果是只读属性，没必要收集依赖。收集了，你是只读的也没法改变属性，没法改变属性你收集依赖的作用就失去了，因为收集依赖的目的就是为了属性改变之后触发effect重新更新视图\n    // 依赖收集：让触发get handler的key属性和对应的effect函数对应起来，建立起映射的关系，方便后边修改值后重新触发这个函数\n    collectDependency(target, key)\n\n    if (isObject(value)) {\n      value = reactive(value)\n    }\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    /**\n     * 当数据更新的时候，在此时需要通知该key对应的reactiveEffect重新执行\n     * 考虑情况：数据是新增的，还是数据是被修改了\n     * 要知道，在vue2当中是没法更改索引，同时也没法监控到数组的长度变化。在vue3解决了\n     * 但是对于一些比较特殊的方法，就需要特殊去处理了。\n     */\n    let oldValue = target[key]\n    // 判断如果是数组的话，同时是拿数组的索引去做值的修改\n    // 比如说arr[1] = xxx -> target: arr key: '1'\n    // 这时候就要去判断说这个key是不是在数组的长度以内。是长度以内的，说明是修改值，不是的话，说明是新增值\n    // 总结：就是利用数组的长度和key作比较来区分是对数组进行值的新增还是修改\n    /**\n     * 思考：对象和数组分别如何知道是新增还是修改\n     * 对象：找对应key是否有值，有就是修改，没就是新增\n     * 数组：找对应索引是否比数组长度小，如果小说明这个位置是有元素的，那就是修改，否则就是新增\n     */\n\n    if (!isKeyExist(target, key)) {\n      // 说明是新增属性\n      emit(EmitEvent.ADD, target, key, value)\n    } else {\n      // 说明是修改属性\n      if (hasChanged(oldValue, value)) {\n        //判断新的值和老的值做比较，是否修改了,只有修改了才跑这个逻辑\n        emit(EmitEvent.EDIT, target, key, value, oldValue)\n      }\n      // 如果值没啥变化，不管他\n    }\n    const result = Reflect.set(target, key, value, receiver)\n    return result\n  }\n}\n\nexport default mutableHandlers\n","import { hasChanged, hasOwnProperty, isArray, isIntegerKey } from '@vue/shared'\nimport { collectDependency, emit } from '../effect'\nimport { EmitEvent } from '../types'\n\nconst shallowReactiveHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    const value = Reflect.get(target, key, receiver)\n    // 如果这个对象不是只读的，那么在经过代理的时候就要进行依赖收集\n    // 等会儿数据变化的时候，就需要对视图View进行更新了\n    // ⚠️：如果是只读的，没必要收集依赖。收集了，你是只读的也没法改变属性，没法改变属性你收集依赖的作用就失去了\n    // 因为收集依赖的目的就是为了属性改变之后触发effect重新更新视图\n    console.log('执行effect时会取值，然后收集依赖')\n    collectDependency(target, key)\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    /**\n     * 当数据更新的时候，在此时需要通知该key对应的reactiveEffect重新执行\n     * 考虑情况：数据是新增的，还是数据是被修改了\n     * 要知道，在vue2当中是没法更改索引，同时也没法监控到数组的长度变化。在vue3解决了\n     * 但是对于一些比较特殊的方法，就需要特殊去处理了。\n     */\n    let oldValue = target[key]\n    // 判断如果是数组的话，同时是拿数组的索引去做值的修改\n    // 比如说arr[1] = xxx -> target: arr key: '1'\n    // 这时候就要去判断说这个key是不是在数组的长度以内。是长度以内的，说明是修改值，不是的话，说明是新增值\n    // 总结：就是利用数组的长度和key作比较来区分是对数组进行值的新增还是修改\n    const hasKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwnProperty(target, key as string)\n\n    if (!hasKey) {\n      // 说明是新增属性\n      emit(EmitEvent.ADD, target, key, value)\n    } else if (hasChanged(oldValue, value)) {\n      //判断新的值和老的值做比较，是否修改了，没修改的话，没卵用。只有修改了才跑这个逻辑\n      // 说明是修改属性\n      emit(EmitEvent.EDIT, target, key, value, oldValue)\n    }\n    const result = Reflect.set(target, key, value, receiver)\n    return result\n  }\n}\n\nexport default shallowReactiveHandlers\n","import { isObject } from '@vue/shared'\nimport { readonly } from '../reactive'\n\nconst readonlyHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    let value = Reflect.get(target, key, receiver)\n    if (isObject(value)) {\n      value = readonly(value)\n    }\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    return console.warn(`${JSON.stringify(target)} is readonly`)\n  }\n}\n\nexport default readonlyHandlers\n","const shallowReadonlyHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    const value = Reflect.get(target, key, receiver)\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    return console.warn(`${JSON.stringify(target)} is readonly`)\n  }\n}\n\nexport default shallowReadonlyHandlers\n","import { isObject } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './proxyHandlers'\n\n/**\n * 是不是响应的，是不是只读的\n */\n// 使用WeakMap会自动垃圾回收，它不会造成内存泄漏，而且存储的key只能是对象\nconst reactiveMap = new WeakMap()\nconst readonlyMap = new WeakMap()\n\n/**\n * createReactiveProxy的实现目标：直接从WeakMap当中取对应target的proxy，如果没有就创建一个再取出来\n * 这样的话，如果多次对同一个对象进行createReactiveProxy，其实获得的都是同一个代理。可以防止一个对象重复代理\n * 即只有一次代理创建， 其他的时候使用createReactiveProxy都是从缓存WeakMap取\n * const o = {}\n * const obj = createReactiveProxy(o)\n * const obj1 = createReactiveProxy(o)\n * 这样子的结果是obj === obj1\n *\n * createReactiveProxy其实就做了两件事:\n * 1. 根据isReadonly去分配readonlyMap和reactiveMap。\n * 2. 往被分配到的map当中设置target->proxy的映射。如果已经有映射了，直接返回对应的proxy\n */\nexport function createReactiveProxy(\n  target: Record<string, any>,\n  {\n    isReadonly,\n    proxyHandlers\n  }: { isReadonly: boolean; proxyHandlers: Record<string, any> }\n) {\n  // 判断要创建的是不是一个只读的代理，那如果是，需要使用只读map去缓存，或者取缓存\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap\n  if (!proxyMap.has(target)) {\n    // 如果WeakMap当中没有target这个key，那就没有target对应的代理，于是创建一个代理\n    const proxy = new Proxy(target, proxyHandlers)\n    // 并且将被代理对象与代理之间建立map联系\n    proxyMap.set(target, proxy)\n  }\n\n  return proxyMap.get(target)\n}\n\n/**\n * reactive其实就做了一件事就是从reactiveMap中取target的proxy代理\n */\nexport function reactive(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: false,\n    proxyHandlers: mutableHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从reactiveMap中取target的proxy代理\n */\nexport function shallowReactive(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: false,\n    proxyHandlers: shallowReactiveHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从readonlyMap中取target的proxy代理\n */\nexport function readonly(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: true,\n    proxyHandlers: readonlyHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从readonlyMap中取target的proxy代理\n */\nexport function shallowReadonly(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: true,\n    proxyHandlers: shallowReadonlyHandlers\n  })\n}\n\n/**\n * reactive/shallowReactive/readonly/shallowReadonly\n * 造成上述四者行为差异的本质在于返回的代理当中的proxyHandlers不同\n * 因为四个proxyHandlers的get和set，分别对应着四种不同的（获取值+设置值）的行为方式\n * 所以导致了返回的proxy在（获取值+设置值）的行为方式\n * 要知道，通过这四种函数获取到的都是代理，通过代理去获取原始对象的值和设置原始对象的值\n */\n"],"names":[],"mappings":"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"}