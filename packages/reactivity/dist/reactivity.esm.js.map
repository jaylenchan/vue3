{"version":3,"file":"reactivity.esm.js","sources":["../../shared/src/index.ts","../src/effect.ts","../src/proxyHandlers/mutableHandlers.ts","../src/proxyHandlers/shallowReactiveHandlers.ts","../src/proxyHandlers/readonlyHandlers.ts","../src/proxyHandlers/shallowReadonlyHandlers.ts","../src/reactive.ts","../src/ref.ts","../src/computed.ts"],"sourcesContent":["/**\n *  判断是否是对象类型（数组，普通对象等）\n */\nexport const isObject = function (value: any) {\n  return typeof value === 'object' && value !== null\n}\n\n/**\n * 判断是不是数组\n */\nexport const isArray = Array.isArray\n\n/**\n * 判断是不是函数\n */\nexport const isFunction = function (value: any) {\n  return typeof value === 'function'\n}\n\n/**\n * 判断是不是整型\n */\nexport const isNumber = function (value: any) {\n  return typeof value === 'number'\n}\n\n/**\n * 判断是不是字符串\n */\nexport const isString = function (value: any) {\n  return typeof value === 'string'\n}\n\n/**\n * 判断是不是数字类型字符串\n */\nexport const isIntegerKey = function (value: any) {\n  return parseInt(value) + '' === value\n}\n\n/**\n * 判断是不是实例属性\n */\nexport const hasOwnProperty = function (target: Record<string, any>, key: string) {\n  return target.hasOwnProperty(key)\n}\n\n/**\n * 判断数组或者对象的对应key是新增还是修改\n * 思考：对象和数组分别如何知道是新增还是修改\n * 对象：找对应key是否有值，有就是修改，没就是新增\n * 数组：找对应索引是否比数组长度小，如果小说明这个位置是有元素的，那就是修改，否则就是新增\n */\nexport const isKeyExist = function (target: Record<string, any>, key: string) {\n  return isArray(target) && isIntegerKey(key)\n    ? Number(key) < target.length\n    : hasOwnProperty(target, key as string)\n}\n\n/**\n * 判断值是否修改了\n */\nexport const hasChanged = function (oldValue: any, newValue: any) {\n  return oldValue !== newValue\n}\n","import { isArray, isIntegerKey } from '@vue/shared'\nimport { EmitEvent } from './types'\n\ntype IReactiveEffect = ((...args: any[]) => any) & {\n  uid: number\n  _isEffect: boolean\n  options: Record<string, any>\n  raw: (...args: any[]) => any\n}\nlet uid = 0\nlet activeEffect: IReactiveEffect // 当前正在运行的reactiveEffect\nconst reactiveEffectStack: Array<IReactiveEffect> = []\nexport const targetMap = new WeakMap<\n  Record<string, any>,\n  Map<string, Set<IReactiveEffect>>\n>()\n\n/** 触发更新，重新执行reactiveEffect */\nexport function emit(\n  eventType: EmitEvent,\n  target: Record<string, any>,\n  key?: string,\n  newValue?: any,\n  oldValue?: any\n) {\n  /**\n   * 如果属性没有收集过依赖，那么直接返回\n   */\n  let dependenciesMap = targetMap.get(target)\n  if (!dependenciesMap) return\n\n  const reactiveEffectsCollectSet = new Set<IReactiveEffect>() // 待会将所有要执行的reactiveEffect集中到这里头，然后一起执行\n  const add = function (reactiveEffectsSet: Set<IReactiveEffect>) {\n    if (reactiveEffectsSet) {\n      // ⚠️：这个是一个Set做循环\n      reactiveEffectsSet.forEach((reactiveEffect) => {\n        reactiveEffectsCollectSet.add(reactiveEffect)\n      })\n    }\n  }\n  // 1. 看看修改的是不是数组的长度，因为改数组的长度影响是比较大的\n  if (isArray(target) && key === 'length') {\n    // 如果对应的长度有依赖收集就需要更新\n    // ⚠️：这是一个map循环，第一个是value，第二个就是key\n    dependenciesMap.forEach((reactiveEffectsSet, key) => {\n      // 如果更改的长度小于收集的索引，那么索引也需要触发effect重新执行\n      if (key === 'length' || key > newValue) {\n        add(reactiveEffectsSet)\n      }\n    })\n  } else {\n    // 可能是对象\n    if (key !== undefined) {\n      // 在这个地方肯定是修改，因为key存在\n      add(dependenciesMap.get(key) as Set<IReactiveEffect>)\n    }\n    // 如果修改了数组当中的某一个索引，怎么办？\n    switch (eventType) {\n      case EmitEvent.ADD: // 如果添加了一个索引，那就触发长度的更新\n        if (isArray(target) && isIntegerKey(key)) {\n          add(dependenciesMap.get('length') as Set<IReactiveEffect>)\n        }\n    }\n  }\n  reactiveEffectsCollectSet.forEach((reactiveEffect) => {\n    if (reactiveEffect.options.scheduler) {\n      reactiveEffect.options.scheduler(reactiveEffect)\n    } else {\n      reactiveEffect()\n    }\n  })\n}\n/**\n * createReactiveEffect就做了一件事：创建一个reactiveEffect，并返回这个reactiveEffect\n */\nfunction createReactiveEffect(\n  fn: (...args: any[]) => any,\n  options: Record<string, any> = {}\n): (...args: any[]) => any {\n  /**\n   * 直接activeEffect= reactiveEffect的弊端\n   * 万一用户，按如下这么写\n   * effect(() => {\n   *   console.log(state.name) -> 此时activeEffect是reactiveEffect.uid 是0\n   *   effect(() => {\n   *     console.log(state.age) -> 此时activeEffect是reactiveEffect.uid 是1\n   *   })\n   *   console.log(state.school) -> 此时activeEffect是reactiveEffect.uid 是1\n   * })\n   * 我们发现在同一个外层作用域activeEffect变了。从uid0变成uid1的reactiveEffect\n   * 那么一个作用域两个不同的reactiveEffect，最终函数执行逻辑就不同了。\n   * 而我们想要的是跑到外层的时候，activeEffect回到uid0的reactiveEffect\n   * 因此我们需要使用一个栈结构去解决这个问题\n   */\n  const reactiveEffect = function () {\n    if (!reactiveEffectStack.includes(reactiveEffect)) {\n      // 保证reactiveEffect没有加入reactiveEffectStack\n      // 因为用户可能使用effect(() => { state.index ++ })\n      // 用户用了++,就不断触发这个函数了，为了防止这一点，需要先判断一下\n      let result\n      try {\n        reactiveEffectStack.push(reactiveEffect)\n        activeEffect = reactiveEffectStack[reactiveEffectStack.length - 1]\n        result = fn() // 这传入effect的函数里头大部分时候都是会取值，一旦取值了，就会触发proxy handler的get方法\n      } finally {\n        reactiveEffectStack.pop()\n        activeEffect = reactiveEffectStack[reactiveEffectStack.length - 1]\n      }\n      return result\n    }\n  }\n  reactiveEffect.uid = uid++ // 给本次创建的reactiveEffect函数一个唯一序号，用于区分不同的reactiveEffect函数\n  reactiveEffect._isEffect = true // 同时需要给创建reactiveEffect一个标志，知道这就是一个reactiveEffect函数\n  reactiveEffect.raw = fn // 同时还要知道一个reactiveEffect对应的原始响应函数是谁，是fn\n  reactiveEffect.options = options // 同时再接着把传入effect中的用户对effect配置保存，便于之后使用\n  return reactiveEffect\n}\n\n/**\n * 收集依赖的问题：如何知道现在准备建立联系的key对应的reactiveEffect是哪一个？并且获取到它来建立联系\n * 解决的方式：设置一个activeEffect，在createReactiveEffect创建一个新的reactiveEffect时，给activeEffect赋值这个ractiveEffect\n * 然后再收集依赖collectDependency的时候将activeEffect取出来用（可以理解成两者在进行通信）\n * collectDependency的实现目标：让对象中的某个属性，收集它对应的reactiveEffect函数，这个值放在了activeEffect\n * 依赖收集其实就干了一件事：让key跟它的reactiveEffect建立联系（本质就是key跟放进effect中的那个函数fn建立联系）\n * 因为reactiveEffect执行了，必定fn也执行。reactiveEffect其实就是在fn基础上，再包装了一些东西，做了额外操作（AOP思想）\n * */\nexport function collectDependency(target: Record<string, any>, key: string) {\n  if (!activeEffect) {\n    /**\n     * 要知道如果effect(() => { state.name })只要这么用，一定会产生一个reactiveEffect\n     * 这个activeEffect也是肯定有值的，如果没有说明肯定没在effect用\n     */\n    return\n  }\n\n  /** WeakMap {\n   *    key: { name: jaylen }\n   *    value: Map { // dependenciesMap\n   *      key : name\n   *      value:\n   *     }\n   * }\n   */\n  let dependenciesMap = targetMap.get(target)\n  if (!dependenciesMap) {\n    dependenciesMap = new Map<string, Set<IReactiveEffect>>()\n    targetMap.set(target, dependenciesMap)\n  }\n  /**\n   * Set [reactiveEffect, reactiveEffect]\n   */\n  let reactiveEffectsSet = dependenciesMap.get(key)\n  if (!reactiveEffectsSet) {\n    reactiveEffectsSet = new Set<IReactiveEffect>()\n    dependenciesMap.set(key, reactiveEffectsSet)\n  }\n\n  if (!reactiveEffectsSet.has(activeEffect)) {\n    reactiveEffectsSet.add(activeEffect)\n  }\n\n  console.log('TargetMap', targetMap)\n}\n\n/**\n * effect的实现目标：做到能够让函数fn里头的数据变化了，这整个函数就能够重新执行\n * 要实现这个效果，必须想办法保存fn，将fn跟fn函数体里头使用的数据对应起来。\n * 方法： 函数fn在执行的时候是会取值的，取值就会走proxy的handler中的get handler。\n * 只需要在get当中让获取值的key属性，和使用的effect产生关联就可以解决对应的关系。其实术语叫做依赖收集\n * 每次调用一次effect，都会重新创建createReactiveEffect一个新的reactiveEffect\n */\nexport function effect(fn: (...args: any[]) => any, options: Record<string, any> = {}) {\n  const reactiveEffect = createReactiveEffect(fn, options)\n\n  if (!options.lazy) {\n    // 如果说，配置当中用户对lazy属性的值传入false或者压根没传这个lazy的话，也就是没有告诉Vue需要懒执行的话\n    reactiveEffect() // 那么，响应式的effect，默认地，是会先执行一次的。其实就是立即执行一次fn\n  }\n\n  return reactiveEffect\n}\n","import { hasChanged, isKeyExist, isObject } from '@vue/shared'\nimport { collectDependency, emit } from '../effect'\nimport { reactive } from '../reactive'\nimport { EmitEvent } from '../types'\n\nconst mutableHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    let value = Reflect.get(target, key, receiver)\n    // ⚠️：如果是只读属性，没必要收集依赖。收集了，你是只读的也没法改变属性，没法改变属性你收集依赖的作用就失去了，因为收集依赖的目的就是为了属性改变之后触发effect重新更新视图\n    // 依赖收集：让触发get handler的key属性和对应的effect函数对应起来，建立起映射的关系，方便后边修改值后重新触发这个函数\n    collectDependency(target, key)\n\n    if (isObject(value)) {\n      value = reactive(value)\n    }\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    /**\n     * 当数据更新的时候，在此时需要通知该key对应的reactiveEffect重新执行\n     * 考虑情况：数据是新增的，还是数据是被修改了\n     * 要知道，在vue2当中是没法更改索引，同时也没法监控到数组的长度变化。在vue3解决了\n     * 但是对于一些比较特殊的方法，就需要特殊去处理了。\n     */\n    let oldValue = target[key]\n    // 判断如果是数组的话，同时是拿数组的索引去做值的修改\n    // 比如说arr[1] = xxx -> target: arr key: '1'\n    // 这时候就要去判断说这个key是不是在数组的长度以内。是长度以内的，说明是修改值，不是的话，说明是新增值\n    // 总结：就是利用数组的长度和key作比较来区分是对数组进行值的新增还是修改\n    /**\n     * 思考：对象和数组分别如何知道是新增还是修改\n     * 对象：找对应key是否有值，有就是修改，没就是新增\n     * 数组：找对应索引是否比数组长度小，如果小说明这个位置是有元素的，那就是修改，否则就是新增\n     */\n\n    if (!isKeyExist(target, key)) {\n      // 说明是新增属性\n      emit(EmitEvent.ADD, target, key, value)\n    } else {\n      // 说明是修改属性\n      if (hasChanged(oldValue, value)) {\n        //判断新的值和老的值做比较，是否修改了,只有修改了才跑这个逻辑\n        emit(EmitEvent.EDIT, target, key, value, oldValue)\n      }\n      // 如果值没啥变化，不管他\n    }\n    const result = Reflect.set(target, key, value, receiver)\n    return result\n  }\n}\n\nexport default mutableHandlers\n","import { hasChanged, hasOwnProperty, isArray, isIntegerKey } from '@vue/shared'\nimport { collectDependency, emit } from '../effect'\nimport { EmitEvent } from '../types'\n\nconst shallowReactiveHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    const value = Reflect.get(target, key, receiver)\n    // 如果这个对象不是只读的，那么在经过代理的时候就要进行依赖收集\n    // 等会儿数据变化的时候，就需要对视图View进行更新了\n    // ⚠️：如果是只读的，没必要收集依赖。收集了，你是只读的也没法改变属性，没法改变属性你收集依赖的作用就失去了\n    // 因为收集依赖的目的就是为了属性改变之后触发effect重新更新视图\n    console.log('执行effect时会取值，然后收集依赖')\n    collectDependency(target, key)\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    /**\n     * 当数据更新的时候，在此时需要通知该key对应的reactiveEffect重新执行\n     * 考虑情况：数据是新增的，还是数据是被修改了\n     * 要知道，在vue2当中是没法更改索引，同时也没法监控到数组的长度变化。在vue3解决了\n     * 但是对于一些比较特殊的方法，就需要特殊去处理了。\n     */\n    let oldValue = target[key]\n    // 判断如果是数组的话，同时是拿数组的索引去做值的修改\n    // 比如说arr[1] = xxx -> target: arr key: '1'\n    // 这时候就要去判断说这个key是不是在数组的长度以内。是长度以内的，说明是修改值，不是的话，说明是新增值\n    // 总结：就是利用数组的长度和key作比较来区分是对数组进行值的新增还是修改\n    const hasKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwnProperty(target, key as string)\n\n    if (!hasKey) {\n      // 说明是新增属性\n      emit(EmitEvent.ADD, target, key, value)\n    } else if (hasChanged(oldValue, value)) {\n      //判断新的值和老的值做比较，是否修改了，没修改的话，没卵用。只有修改了才跑这个逻辑\n      // 说明是修改属性\n      emit(EmitEvent.EDIT, target, key, value, oldValue)\n    }\n    const result = Reflect.set(target, key, value, receiver)\n    return result\n  }\n}\n\nexport default shallowReactiveHandlers\n","import { isObject } from '@vue/shared'\nimport { readonly } from '../reactive'\n\nconst readonlyHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    let value = Reflect.get(target, key, receiver)\n    if (isObject(value)) {\n      value = readonly(value)\n    }\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    return console.warn(`${JSON.stringify(target)} is readonly`)\n  }\n}\n\nexport default readonlyHandlers\n","const shallowReadonlyHandlers = {\n  get: function (target: Record<string, any>, key: string, receiver: any) {\n    const value = Reflect.get(target, key, receiver)\n    return value\n  },\n  set: function (target: Record<string, any>, key: string, value: any, receiver: any) {\n    return console.warn(`${JSON.stringify(target)} is readonly`)\n  }\n}\n\nexport default shallowReadonlyHandlers\n","import { isObject } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './proxyHandlers'\n\n/**\n * 是不是响应的，是不是只读的\n */\n// 使用WeakMap会自动垃圾回收，它不会造成内存泄漏，而且存储的key只能是对象\nconst reactiveMap = new WeakMap()\nconst readonlyMap = new WeakMap()\n\n/**\n * createReactiveProxy的实现目标：直接从WeakMap当中取对应target的proxy，如果没有就创建一个再取出来\n * 这样的话，如果多次对同一个对象进行createReactiveProxy，其实获得的都是同一个代理。可以防止一个对象重复代理\n * 即只有一次代理创建， 其他的时候使用createReactiveProxy都是从缓存WeakMap取\n * const o = {}\n * const obj = createReactiveProxy(o)\n * const obj1 = createReactiveProxy(o)\n * 这样子的结果是obj === obj1\n *\n * createReactiveProxy其实就做了两件事:\n * 1. 根据isReadonly去分配readonlyMap和reactiveMap。\n * 2. 往被分配到的map当中设置target->proxy的映射。如果已经有映射了，直接返回对应的proxy\n */\nexport function createReactiveProxy(\n  target: Record<string, any>,\n  {\n    isReadonly,\n    proxyHandlers\n  }: { isReadonly: boolean; proxyHandlers: Record<string, any> }\n) {\n  // 判断要创建的是不是一个只读的代理，那如果是，需要使用只读map去缓存，或者取缓存\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap\n  if (!proxyMap.has(target)) {\n    // 如果WeakMap当中没有target这个key，那就没有target对应的代理，于是创建一个代理\n    const proxy = new Proxy(target, proxyHandlers)\n    // 并且将被代理对象与代理之间建立map联系\n    proxyMap.set(target, proxy)\n  }\n\n  return proxyMap.get(target)\n}\n\n/**\n * reactive其实就做了一件事就是从reactiveMap中取target的proxy代理\n */\nexport function reactive(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: false,\n    proxyHandlers: mutableHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从reactiveMap中取target的proxy代理\n */\nexport function shallowReactive(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: false,\n    proxyHandlers: shallowReactiveHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从readonlyMap中取target的proxy代理\n */\nexport function readonly(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: true,\n    proxyHandlers: readonlyHandlers\n  })\n}\n\n/**\n * reactive其实就做了一件事就是从readonlyMap中取target的proxy代理\n */\nexport function shallowReadonly(target: any) {\n  // 如果不是对象类型，是普通类型或者函数类型，直接返回target\n  if (!isObject(target)) return target\n  return createReactiveProxy(target, {\n    isReadonly: true,\n    proxyHandlers: shallowReadonlyHandlers\n  })\n}\n\n/**\n * reactive/shallowReactive/readonly/shallowReadonly\n * 造成上述四者行为差异的本质在于返回的代理当中的proxyHandlers不同\n * 因为四个proxyHandlers的get和set，分别对应着四种不同的（获取值+设置值）的行为方式\n * 所以导致了返回的proxy在（获取值+设置值）的行为方式\n * 要知道，通过这四种函数获取到的都是代理，通过代理去获取原始对象的值和设置原始对象的值\n */\n","import { hasChanged, isArray, isObject } from '@vue/shared'\nimport { collectDependency, emit } from './effect'\nimport { reactive } from './reactive'\nimport { EmitEvent } from './types'\nclass RefImpl {\n  public _value: any // 只是声明一个属性，但是没有执行this.xx = xx\n  public __v_isRef = true // 表示是一个ref属性\n  //参数当中增加修饰符，表示这个属性被放到了实例当中，即声明了对应同名属性并且放到了this.同名属性 = 同名属性赋值\n  constructor(public rawVal: any, public isShallow: boolean) {\n    this._value = isShallow ? rawVal : convert(rawVal)\n  }\n\n  get value() {\n    // 取值就是使用xx.value，实际上会代理到_value\n    collectDependency(this, 'value')\n    return this._value\n  }\n\n  set value(newVal) {\n    if (hasChanged(this.rawVal, newVal)) {\n      // 判断老值相对于新值是否有变化\n      this.rawVal = newVal // 有变化的话，老的值变成新的值\n      this._value = this.isShallow ? newVal : convert(newVal)\n      emit(EmitEvent.EDIT, this, 'value', newVal)\n    }\n  }\n}\n\nclass ObjectRefImpl {\n  public __v_isRef = true\n  constructor(public target: Record<string, any>, public key: string) {}\n\n  get value() {\n    return this.target[this.key]\n  }\n\n  set value(newVal) {\n    this.target[this.key] = newVal\n  }\n}\n\nfunction convert(value: any) {\n  return isObject(value) ? reactive(value) : value\n}\n\nfunction createRef(value: any, isShallow: boolean = false) {\n  return new RefImpl(value, isShallow)\n}\n\n/**\n * ref和reactive的区别：reactive内部采用的是proxy，而ref内部使用的是defineProperty\n */\nexport function ref(value: any) {\n  // 将普通类型变成一个对象。当然也可以value是对象，但是对象一般用reactive\n  return createRef(value)\n}\n\nexport function shallowRef(value: any) {\n  return createRef(value, true)\n}\n\n/**\n * toRef：可以将一个对象的属性，变成ref\n */\nexport function toRef(target: Record<string, any>, key: string) {\n  return new ObjectRefImpl(target, key)\n}\n\nexport function toRefs(object: Record<string, any>) {\n  const result = isArray(object) ? new Array(object.length) : ({} as Record<string, any>)\n\n  for (let key in object) {\n    result[key] = toRef(object, key)\n  }\n\n  return result\n}\n","import { isFunction } from '@vue/shared'\nimport { effect } from './effect'\ntype IParams = {\n  get: (...args: any[]) => any\n  set: (...args: any[]) => any\n}\n\ntype IGetter = IParams['get']\ntype ISetter = IParams['set']\n\nclass ComputedRefImpl {\n  public _dirty: boolean = true\n  public _value: any\n  public effect\n  constructor(public getter: IGetter, public setter: ISetter) {\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () => {\n        if (!this._dirty) {\n          this._dirty = true\n        }\n      }\n    })\n  }\n\n  get value() {\n    if (this._dirty) {\n      this._value = this.effect()\n      this._dirty = false\n    }\n\n    return this._value\n  }\n\n  set value(newVal) {\n    this.setter(newVal)\n  }\n}\n\nexport function computed(params: IGetter | IParams) {\n  let getter: IGetter\n  let setter: ISetter\n\n  if (isFunction(params)) {\n    getter = params as IGetter\n    setter = () => {\n      console.warn('computed param is readonly')\n    }\n  } else {\n    getter = (params as IParams).get\n    setter = (params as IParams).set\n  }\n\n  return new ComputedRefImpl(getter, setter)\n}\n"],"names":[],"mappings":"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"}